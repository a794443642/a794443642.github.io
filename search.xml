<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>多线程基础</title>
    <url>/2022/04/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="线程启动方式"><a href="#线程启动方式" class="headerlink" title="线程启动方式"></a>线程启动方式</h2><h4 id="1-通过直接继承Thread-重写run方法"><a href="#1-通过直接继承Thread-重写run方法" class="headerlink" title="1.通过直接继承Thread 重写run方法"></a>1.通过直接继承Thread 重写run方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">StudentThread</span> <span class="variable">studentThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StudentThread</span>(<span class="string">&quot;小明&quot;</span>,punishment);</span><br></pre></td></tr></table></figure>

<h4 id="2-通过实现Runable接口-重现run方法-然后作为Thread的入参数"><a href="#2-通过实现Runable接口-重现run方法-然后作为Thread的入参数" class="headerlink" title="2.通过实现Runable接口 重现run方法 然后作为Thread的入参数"></a>2.通过实现Runable接口 重现run方法 然后作为Thread的入参数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">xiaoming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">StudentRunnable</span>(<span class="string">&quot;小明&quot;</span>,punishment),<span class="string">&quot;小明&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="以上两种方式实际为一种："><a href="#以上两种方式实际为一种：" class="headerlink" title="以上两种方式实际为一种："></a>以上两种方式实际为一种：</h4><h4 id="此外还有Future方法"><a href="#此外还有Future方法" class="headerlink" title="此外还有Future方法"></a>此外还有Future方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Causes this thread to begin execution; the Java Virtual Machine</span></span><br><span class="line"><span class="comment">     * calls the &lt;code&gt;run&lt;/code&gt; method of this thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The result is that two threads are running concurrently: the</span></span><br><span class="line"><span class="comment">     * current thread (which returns from the call to the</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method).</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * It is never legal to start a thread more than once.</span></span><br><span class="line"><span class="comment">     * In particular, a thread may not be restarted once it has completed</span></span><br><span class="line"><span class="comment">     * execution.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@exception</span>  IllegalThreadStateException  if the thread was already</span></span><br><span class="line"><span class="comment">     *               started.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>        #run()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>        #stop()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is not invoked for the main method thread or &quot;system&quot;</span></span><br><span class="line"><span class="comment">     * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">     * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * A zero status value corresponds to state &quot;NEW&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">     * so that it can be added to the group&#x27;s list of threads</span></span><br><span class="line"><span class="comment">     * and the group&#x27;s unstarted count can be decremented. */</span></span><br><span class="line">    group.add(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">started</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        start0();</span><br><span class="line">        started = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                group.threadStartFailed(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">            <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">              it will be passed up the call stack */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="start-逻辑如下"><a href="#start-逻辑如下" class="headerlink" title="start()逻辑如下"></a>start()逻辑如下</h3><p>1.判断线程状态，是否可以启动</p>
<p>2.把当前线程加入group中</p>
<p>3.调用start0()方法</p>
<p>Start0()方法为JNI方法，JNI方法是java和其它语言交互的方式。同样也是java代码和虚拟机交互的方式，虚拟机就是由C++和汇编所编写，由start方法注解得知java虚拟机最后会运行run方法</p>
<p><img src="/../../../../img/image-20210811160611426.png"></p>
<h4 id="3Run方法是通过调用Runable-target"><a href="#3Run方法是通过调用Runable-target" class="headerlink" title="3Run方法是通过调用Runable target"></a>3Run方法是通过调用Runable target</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* What will be run. */</span></span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java中多线程的实现采用了模版模式。Thread是模版对象，负责线程相关的逻辑，比如线程的创建、运行以及各种操作。而线程真正的业务逻辑则被剥离出来，交由Runnable的实现类去实现。线程操作和业务逻辑完全解耦，普通开发者只需要聚焦在业务逻辑实现。</p>
<p>执行业务逻辑，是Thread对象的生命周期中的重要一环。这一步通过调用传入Runnable的run方法实现。thread线程整体逻辑就是一个模版，把其中一个步骤剥离出来由其他类实现，这就是模版方法模式。</p>
<h3 id="java中线程状态"><a href="#java中线程状态" class="headerlink" title="java中线程状态"></a>java中线程状态</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新建状态(New)：至今尚未启动的线程的状态。线程刚被创建，但尚未启动。如</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 就绪状态(Runnable):当调用线程对象的start()方法(t.start();)，线程即进入就绪状态。处于就绪状态的			*线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *处于运行状态中的线程由于某种(当线程处于运行状态时，试图获得某个对象的同步锁时，如果该对象的同步锁已经			*被其他线程占用，Java虚拟机就会把这个线程放到这个对象的锁池中，这涉及到“线程同步”的内容。【线程在获取		 *synchronized同步锁失败(因为锁被其它线程所占用)】)原因，暂时放弃对CPU的使用权，停止执行，此时进入		   *阻塞状态，直到其进入到就绪状态，才有机会再次被CPU调用以进入到运行状态.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位于对象等待池中的阻塞状态(Blocked in object’s wait pool)：当线程处于运行状态时，如果执行了某			*个对象的wait()方法，Java虚拟机就会把线程放到这个对象的等待池中，这涉及到“线程通信”的内容。处于这种		 *状态的线程不会被分配处理器执行时间，它们要等待被其他线程显示唤醒。以下方法会让线程陷入无限期的等待状    		 *态：</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">     *没有设置timeout参数的Object::wait()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *没有设置timeout参数的Thread::join()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *LockSupport::park()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *限期等待(Timed Waiting)：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待其他线程显示唤		 *醒，在一定时间后它们由系统自动唤醒。以下方法会让线程进入期限等待状态：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *Thread::sleep()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *设置了timeout参数的Object::wait()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *设置了timeout参数的Thread::join()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *LockSupport::parkNanos()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">      LockSupport::parkUntil()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *处于这种状态的线程也不会被分配处理器执行时间，不过无须等待其他线程显示唤醒，在一定时间后它们由系统自		 *动唤醒。以下方法会让线程进入期限等待状态：</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *Thread::sleep()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *设置了timeout参数的Object::wait()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *设置了timeout参数的Thread::join()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *LockSupport::parkNanos()方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *LockSupport::parkUntil()方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程执行完成 或者被中断的时候变成TERMINATED</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行状态(Running)：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；</p>
<p>“阻塞状态”与“等待状态”的区别：“阻塞状态”在等待着获取一个排它锁，这个事件将在另一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作发生。在程序进入同步区域的时候，线程就会进入阻塞状态。</p>
<p><img src="/../../../../img/image-20210811165610968.png"></p>
<h2 id="Thread-api"><a href="#Thread-api" class="headerlink" title="Thread api"></a>Thread api</h2><h3 id="sleep方法"><a href="#sleep方法" class="headerlink" title="sleep方法"></a>sleep方法</h3><p>线程的 sleep 方法会使线程休眠指定的时间长度。休眠的意思是，当前逻辑执行到此不再继续执行，而是等待指定的时间。但在这段时间内，该线程持有的 monitor 锁并不会被放弃</p>
<p>sleep有两个重载方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis, <span class="type">int</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                                <span class="string">&quot;nanosecond timeout value out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt;= <span class="number">500000</span> || (nanos != <span class="number">0</span> &amp;&amp; millis == <span class="number">0</span>)) &#123;</span><br><span class="line">            millis++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sleep(millis);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>第二个支持休眠时间到纳秒级，但是并不能精确到纳秒级别，代码如上。</p>
<h3 id="yield方法"><a href="#yield方法" class="headerlink" title="yield方法"></a>yield方法</h3><p>线程自愿放弃cpu资源，不过这只是给 CPU 一个提示，当 CPU 资源并不紧张时，则会无视 yield 提醒。如果 CPU 没有无视 yield 提醒，那么当前 CPU 会从 RUNNING 变为 RUNNABLE 状态，此时其它等待 CPU 的 RUNNABLE 线程，会去竞争 CPU 资源。（yield的线程是不会马上竞争cpu资源的）</p>
<h3 id="currentThread方法"><a href="#currentThread方法" class="headerlink" title="currentThread方法"></a>currentThread方法</h3><p>获取当前线程实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.currentThread();</span><br><span class="line"><span class="comment">//获取线程名称</span></span><br><span class="line">Thread.currentThread().getName();</span><br><span class="line"><span class="comment">//获取当前线程ID</span></span><br><span class="line">Thread.currentThread().getId();</span><br></pre></td></tr></table></figure>

<h3 id="SetPriority方法"><a href="#SetPriority方法" class="headerlink" title="SetPriority方法"></a>SetPriority方法</h3><p>此方法用于设置线程的优先级。每个线程都有自己的优先级数值，当 CPU 资源紧张的时候，优先级高的线程获得 CPU 资源的概率会更大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span> &#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Thread 有自己的最小和最大优先级数值，范围在 1-10。如果不在此范围内，则会报错。另外如果设置的 priority 超过了线程所在组的 priority ，那么只能被设置为组的最高 priority 。最后通过调用 native 方法 setPriority0 进行设置。</p>
<h3 id="interrupt-相关方法"><a href="#interrupt-相关方法" class="headerlink" title="interrupt 相关方法"></a>interrupt 相关方法</h3><p>我在第一次学习 interrupt 的时候，第一感觉是让线程中断。其实inerrupt 方法的作用是让可中断方法，比如让 sleep 中断。也就是说其中断的并不是线程的逻辑，中断的是线程的阻塞。</p>
<p>注：</p>
<ol>
<li>调用 interrupt 方法，并不会影响可中断方法之外的逻辑。线程不会中断，会继续执行。这里的中断概念并不是指中断线程；</li>
<li>一旦调用了 interrupt 方法，那么线程的 interrupted 状态会一直为 ture（没有通过调用可中断方法（即run方法中没有可中断方法）或者其他方式主动清除标识的情况下如：Thread.interrupted()这个方法其实和成员方法 isInterrupted 方法类似，都是返回了 interrupted 状态。不同就是 interrupted 方法返回状态后，如果为 true 则会清除掉状态。而 isInterrupted 则不会；</li>
</ol>
<h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join 方法"></a>join 方法</h3><p>比如主线程需要做两件没有相互依赖的事情，那么可以起 A、B 两个线程分别去做。通过调用 A、B 的 join 方法，让主线程 block 住，直到 A、B 线程的工作全部完成，才继续走下去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">backendDev</span> <span class="operator">=</span> createWorker(<span class="string">&quot;backed dev&quot;</span>,<span class="string">&quot;backend coding&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">frontendDev</span> <span class="operator">=</span> createWorker(<span class="string">&quot;frontend dev&quot;</span>,<span class="string">&quot;frontend coding&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tester</span> <span class="operator">=</span> createWorker(<span class="string">&quot;tester&quot;</span>,<span class="string">&quot;testing&quot;</span>);</span><br><span class="line">        backendDev.start();</span><br><span class="line">        frontendDev.start();</span><br><span class="line">        backendDev.join();</span><br><span class="line">        frontendDev.join();</span><br><span class="line">        tester.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title function_">createWorker</span><span class="params">(String role,String work)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;I finished &quot;</span>+ work + <span class="string">&quot;as a &quot;</span>+ role);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 join 方法后 block 的并不是被调用的 <strong>backendDev</strong> 或 <strong>frontendDev 线程</strong>，而是调用方线程</p>
<h2 id="Object中wait-x2F-notify"><a href="#Object中wait-x2F-notify" class="headerlink" title="Object中wait&#x2F;notify"></a>Object中wait&#x2F;notify</h2><h3 id="1-wait-x2F-notify-概念"><a href="#1-wait-x2F-notify-概念" class="headerlink" title="1. wait&#x2F;notify 概念"></a>1. wait&#x2F;notify 概念</h3><p>原本 RUNNING 的线程，可以通过调用 wait 方法，进入 BLOCKING 状态。此线程会放弃原来持有的锁。而调用 notify 方法则会唤醒 wait 的线程，让其继续往下执行。</p>
<h3 id="2、同步与异步"><a href="#2、同步与异步" class="headerlink" title="2、同步与异步"></a>2、同步与异步</h3><p>异步：多个线程同时执行。</p>
<p>同步：多个线程同时执行过程中，可能会访问共享资源，确保同一时间只能有一个线程访问，就叫同步。</p>
<p>java中最基本的同步方式是使用Synchoronized关键字</p>
<h3 id="3、使用wait-x2F-notify"><a href="#3、使用wait-x2F-notify" class="headerlink" title="3、使用wait&#x2F;notify"></a>3、使用wait&#x2F;notify</h3><p> synchronized 所使用的对象，只是用来记录等待同步操作的线程集合。他相当于一位排队管理员，所有线程都要在此排队，并接受他的管理，他说谁能进就可以进。另外他维护了一个 wait set，所有调用了 wait 方法的线程都保存于此。一旦有线程调用了同步对像的 notify 方法，那么 wait set 中的线程就会被 notify，继续执行自己的逻辑。</p>
<p><img src="/../../../../img/image-20210812142021612.png"></p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Future解析</title>
    <url>/2022/04/13/Future%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>Future 是一个接口，而 FutrueTask 则是他的实现，我们看一下它们的继承关系:</p>
<p><img src="/../../../../img/image-20210914111210636.png"></p>
<p>FutureTask 不但实现了 Future 而且实现了 Runnable 接口。这也是为什么它能作为参数传入 Thread 构造方法。</p>
<h3 id="Future-接口有哪些方法"><a href="#Future-接口有哪些方法" class="headerlink" title="Future 接口有哪些方法:"></a>Future 接口有哪些方法:</h3><p><img src="/../../../../img/image-20210914111650153.png"></p>
<p>cancel 用于尝试取消任务。<br>get 用于等待并获取任务执行结果。带时间参数的 get 方法只会等待指定时间长度。 isCancelled 返回任务在完成前是否已经被取消。<br>isDone 返回任务是否完成。</p>
<h4 id="FutureTask-构造方法"><a href="#FutureTask-构造方法" class="headerlink" title="FutureTask 构造方法"></a>FutureTask 构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable;</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要传入 Callable 的实现，Callable 是一个接口，定义了 call 方法，返回 V 类型。 然后定义了 FutureTask 的状态为 NEW。FutrueTask 定义了如下状态:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<h4 id="run-方法解析"><a href="#run-方法解析" class="headerlink" title="run 方法解析"></a>run 方法解析</h4><p>FutrueTask 实现了 Runnbale 接口，所以 Thread 运行后实际上执行的是 FutrueTask 的 run 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//如果此时状态不为NEW直接结束</span></span><br><span class="line">    <span class="comment">// 如果为NEW，但是CAS操作把本线程写入为runner时，发现runner已经不为null，那么也直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//取得Callable对象</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="type">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//运行Callable对象的call方法，并且取得返回值。</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                ran = <span class="literal">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果call方法成功执行结束，那么把执行结果设置给成员变量outcome;</span></span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心逻辑就是执行运行 Callable 对象的 call 方法，把返回结果写入 outcome。outcome 用来保存计算结果。</p>
<p>保存计算结果则是通过 set 方法。</p>
<h4 id="set-方法解析"><a href="#set-方法解析" class="headerlink" title="set 方法解析"></a>set 方法解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V v)</span> &#123;</span><br><span class="line">    <span class="comment">//状态还是NEW，保存计算结果给outcome</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">//更新状态为NORMAL</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        <span class="comment">//唤醒等待的线程</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有被取消则会保存计算结果 v 到 outcome。然后更新最终状态为 NORMAL。最后调用 finishCompletion 方法 唤醒阻塞的线程。代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishCompletion</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="comment">//遍历等待线程，结束等待</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="literal">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//结束等待线程的挂起</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="literal">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果没有下一个等待线程，那么结束循环</span></span><br><span class="line">                <span class="type">WaitNode</span> <span class="variable">next</span> <span class="operator">=</span> q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="literal">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//全部完成后回调FutrueTask的done方法。done方法为空，可以由子类实现</span></span><br><span class="line">    done();</span><br><span class="line">    <span class="comment">//清除callable</span></span><br><span class="line">    callable = <span class="literal">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="get-方法解析"><a href="#get-方法解析" class="headerlink" title="get 方法解析"></a>get 方法解析</h4><p>get 方法用于获取任务的返回值，如果还没有执行完成，则会阻塞，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="comment">//获取当前Task的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="comment">//如果还没有完成，则阻塞等待完成</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="comment">//获取任务执行的返回结果</span></span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>awaitDone 的代码:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">awaitDone</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//计算等待截止时长</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="type">WaitNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">queued</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//当前线程如果被打断，则不再等待。从等待链表中移除</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取得目前的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="comment">//如果已经执行完成，清空q节点保存的线程</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">null</span>)</span><br><span class="line">                q.thread = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果正在执行，让出CPU执行权</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="comment">//没有进入以上分支，运行到此分支，这说明此线程确实需要开始等待了，</span></span><br><span class="line">        <span class="comment">// 那么如果还未为此线程建立关联的等待节点，则进行创建。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">        <span class="comment">//通过CAS把此线程的等待node加入到连表中。失败的话，下次循环若能运行到此分支，会继续添加。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="comment">//如果设置了超时，检查是否超时。超时的话结束等待。 否则挂起超时时长</span></span><br><span class="line">        <span class="comment">// 如果没有设置超时时长，则永久挂起</span></span><br><span class="line">        <span class="comment">// 回到上面的finishCompletion方法，等到task执行完成后会执行LockSupport.unpark(t)，结束阻塞。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="report-方法"><a href="#report-方法" class="headerlink" title="report 方法:"></a>report 方法:</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> V <span class="title function_">report</span><span class="params">(<span class="type">int</span> s)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">    <span class="comment">//获取执行结果</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> outcome;</span><br><span class="line">    <span class="comment">//NORMAL为正常结束，那么直接把X转型后返回</span></span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="comment">//如果任务被取消了，则抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CancellationException</span>();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExecutionException</span>((Throwable)x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>outcome 保存的就是任务的执行结果。根据此时的状态，选择返回执行结果还是抛出取消的异常。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后我们总结下 FutureTask 的代码<br>1、FutureTask 实现 Runnable 和 Future 接口;<br>2、在线程上运行 FutureTask 后，run 方法被调用，run 方法会调用传入的 Callable 接口的 call 方法;<br>3、拿到返回值后，通过 set 方法保存结果到 outcome，并且唤醒所有等待的线程;<br>4、调用 get 方法获取执行结果时，如果没有执行完毕，则进入等待，直到 set 方法调用后被唤醒。</p>
<p>下图示意了两个线程运行 task 和 get 时的程序逻辑:</p>
<p><img src="/../../../../img/image-20210914115941405.png"></p>
<p>Future 模式在实际开发中有着大量的应用场景。比如说微服务架构中，需要调用不同服务接口获取数据，但是接口 调用间并无依赖关系，那么可以通过 FutureTask 并发调用，然后再执行后续逻辑。如果我们采用串行的方式，则 需要一个接口返回后，再调用下一个接口。</p>
]]></content>
      <tags>
        <tag>java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
</search>
